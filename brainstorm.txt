
. make promises cause a real error if they are rejected without being handled. 
	/ as-is, they report an error, but continue executing.
	  Where does windower put lua's original error() function?

. From top of main file
	-- stats_i_care_about_on("war", "auto_attack", "ws", "def" ...)
		-- or ("rng", {ratt=100, racc=75, ...}, {exclude_list})
	-- loadout("rng") -- pull from storage
	--
	-- set_priority_multiplier(number) -- ratio of how much of higher priority stat to give up for a lower priority stat


+ 3d projection filter
+ for each axis:
	sort in descending order of that coordinate and iterate from max down:
		if next point <= in all other axes than the last point, remove it
		if they're equal in primary iteration axis, 
			compare all equal elements to the element before that equal range.
			when you have multiple goods in the prev round, see if it increases the stat from the minimum of them.
			Silver_Skree: The next point needs to have AN axis value that's better than the combined minimums of all the last good points

+ Rings and Earrings are slot-flagged for only the left
	. minimum item id goes in left slot to avoid duplicates of just left-right swapped sets
	. if you only have one ring, since cur starts at {1,1,1...} it thinks they are equal.
		need to consider empty slot
+ also weapons if dual wielding

. Highest damage weapon should go in main hand when dual wielding
	. sort weapons list by damage in descending order before building set list

/ handle restricted slots

. add some small value for any stat given?
	general item level?
+ whether more or less of a stat counts as good (delay -)
	dusk gear
	consider naked slot ?
	see purpose.want_negative={[STAT_NAME] = true}

+ filter out of gear list any stat you care about that's negative

. Add a member gear_list:resource(slot) and maybe other info (weapon damage?)
	(to avoid having inner functions in every purpose utility)
	points to windower resource for that item

+ filter duplicate gear from relevant_gear except rings, earrings, weapons
	e.g. stacks of arrows
	I think this is being done by nature of the per-slot filter step, if it's not an improvement it won't be added.

. certain weapons can not be dual wielded / sub slot

. Tilde items e.g. Rajas ring

theoretical DPS = accuracy * swing_damage * number_of_swings / delay

Initialize to middle of the pareto front
use events to instantiate / activate a purpose
	e.g. use status_change to engaged to trigger the auto_attack purpose, or maybe "build tp"

precast is fast cast
mid cast is int, mab, macc etc

. "On (day):" example Ice Ring (from Shiva)
  "(x weather):" yadda yadda

. gallant coronet and valor surcoat need to remain equipped for cover mod to stay in effect

. relevant purposes for a job/subjob combination
	will affect loadout

acc1 - eva = hit%1
acc_target - eva = .94
hit% = clamp(  0.75 + (acc - eva)/2  ,  0.2, 0.95)

TODO: .en --> [LOCALE]

. <Roach> excluding MDB and MDT effects, each blm's base damage can be approximated as (1+MAB/100)*floor(INT + ElementalMagicSkill/6)*3.5
--------------------------
Skree

● Reactionary equip change cooldown timers
	i.e. if there's no data on a mob, let the system make changes rapidly and learn a lot of information about the mob
	or, if perf is poor, bring the cooldown way down and experiment quickly to find something that improves perf
	if, when the cooldown ends and we check to see what set we should be using, it's the same set we have on (no change required), then increse the cooldown timer
	But if we suddenly start getting a lot of bad perf, we should probably bypass the cooldown timer (heuristics passes a critical low threshold) and reset it to 0

● If you miss consecutive times, make the tradeoffs for each successive miss more severe

● When we get an event that'd affect heuristics, determine if the data is "bad" or "good" i.e. don't count dodges from Perfect Dodge or shadows or 0 damage from Invincible as actual misses
	Dan: A zero-damage hit will still be recognized as a hit based on the message, but perfect dodge status may need to be special cased

● HOW DO I ACCESSED AUGMENT

● Filter gear for any piece of equipment that has no extra bonuses and worse stats than other gear in its slot

● Special case: Detect if gear has "set bonus" on it and scan for other pieces of the set. If the set can be assembled, forcibly include the set pieces.

● Currently, we're feeding a gear_list that has been filtered down to currently-equippable items into the permutator.
	Do we want to instead permute ALL gear with a subtractive blend of jobs as we go, and build a larger but more general-purpose cache on disk?

● ^ OR, iterate over the set of all purposes, and check whether each piece of gear (or each set?) gives ANY stats that are beneficial to a given purpose, and cache that it's relevant to that purpose
